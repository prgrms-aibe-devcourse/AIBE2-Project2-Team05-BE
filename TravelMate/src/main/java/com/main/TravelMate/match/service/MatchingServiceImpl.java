package com.main.TravelMate.match.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.main.TravelMate.alarm.domain.Alarm;
import com.main.TravelMate.alarm.service.AlarmService;
import com.main.TravelMate.match.domain.MatchingStatus;
import com.main.TravelMate.match.dto.MatchRecommendationDto;
import com.main.TravelMate.match.dto.MatchRequestDto;
import com.main.TravelMate.match.entity.Matching;
import com.main.TravelMate.match.repository.MatchingRepository;
import com.main.TravelMate.plan.entity.TravelPlan;
import com.main.TravelMate.plan.repository.TravelPlanRepository;
import com.main.TravelMate.profile.entity.Profile;
import com.main.TravelMate.user.entity.User;
import com.main.TravelMate.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;

@Service
@RequiredArgsConstructor
public class MatchingServiceImpl implements MatchingService {

    private final UserRepository userRepository;
    private final TravelPlanRepository travelPlanRepository;
    private final MatchingRepository matchingRepository;
    private final AlarmService alarmService;

    @Override
    public List<MatchRecommendationDto> getRecommendations(Long userId) {
        User me = userRepository.findById(userId).orElseThrow();
        TravelPlan myPlan = travelPlanRepository.findFirstByUserIdOrderByStartDateDesc(userId)
                .orElseThrow(() -> new RuntimeException("ÌîåÎûú ÏóÜÏùå"));

        List<Long> excludedPlanIds = matchingRepository.findAllBySenderId(userId).stream()
                .map(m -> m.getPlan().getId())
                .toList();

        List<TravelPlan> candidates = travelPlanRepository
                .findRecruitingPlansExcludingUser(userId)
                .stream()
                .filter(p -> !excludedPlanIds.contains(p.getId()))
                .filter(p -> p.getCurrentPeople() + myPlan.getCurrentPeople() <= p.getNumberOfPeople())
                .toList();

        return candidates.stream()
                .map(p -> {
                    int score = calculateCompatibilityScore(myPlan, p);
                    if (score >= 60) {
                        return new MatchRecommendationDto(
                                p.getUser().getId(),
                                p.getUser().getNickname(),
                                p.getLocation(),
                                p.getStartDate(),
                                p.getEndDate(),
                                p.getId(),
                                score
                        );
                    } else {
                        return null; // Ï†êÏàò ÎÇÆÏúºÎ©¥ Ï∂îÏ≤ú Ï†úÏô∏
                    }
                })
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(MatchRecommendationDto::getCompatibilityScore).reversed()) // ÎÜíÏùÄ Ï†êÏàò Ïö∞ÏÑ†
                .toList();
    }

    private int calculateCompatibilityScore(TravelPlan myPlan, TravelPlan target) {
        int score = 0;

        // ‚úÖ Î™©Ï†ÅÏßÄ Ïú†ÏÇ¨ÎèÑ
        if (target.getLocation().equalsIgnoreCase(myPlan.getLocation())) {
            score += 50;
        } else if (isSimilarRegion(myPlan.getLocation(), target.getLocation())) {
            score += 30;
        }

        // ‚úÖ ÏùºÏ†ï Í≤πÏπ® ÎπÑÏú® (ÏñëÏ™Ω Í∏∞Ï§Ä ÌèâÍ∑†)
        int overlap = calculateOverlappingDays(myPlan.getStartDate(), myPlan.getEndDate(),
                target.getStartDate(), target.getEndDate());
        if (overlap > 0) {
            long myDays = ChronoUnit.DAYS.between(myPlan.getStartDate(), myPlan.getEndDate()) + 1;
            long otherDays = ChronoUnit.DAYS.between(target.getStartDate(), target.getEndDate()) + 1;

            double myRatio = (double) overlap / myDays;
            double otherRatio = (double) overlap / otherDays;
            double avgRatio = (myRatio + otherRatio) / 2;

            score += (int) (avgRatio * 25); // ÏµúÎåÄ 25Ï†ê
        }

        // ‚úÖ Ïó¨Ìñâ ÏùºÏàò Ï∞®Ïù¥ (¬±2 Ïù¥ÎÇ¥Î©¥ 10Ï†ê, Ïù¥ÌõÑ Ï†êÏ†ê Í∞êÏ†ê)
        long myDays = ChronoUnit.DAYS.between(myPlan.getStartDate(), myPlan.getEndDate()) + 1;
        long otherDays = ChronoUnit.DAYS.between(target.getStartDate(), target.getEndDate()) + 1;
        long diffDays = Math.abs(myDays - otherDays);
        if (diffDays <= 2) {
            score += 10;
        } else if (diffDays <= 4) {
            score += 5;
        }

        // ‚úÖ Î™®Ïßë Ïù∏ÏõêÏàò Ïú†ÏÇ¨ÎèÑ
        int diffPeople = Math.abs(myPlan.getNumberOfPeople() - target.getNumberOfPeople());
        if (diffPeople == 0) score += 15;
        else if (diffPeople == 1) score += 10;
        else if (diffPeople == 2) score += 5;

        try {
            ObjectMapper mapper = new ObjectMapper();

            List<String> myStyles = mapper.readValue(myPlan.getStyles(), new TypeReference<>() {});
            List<String> targetStyles = mapper.readValue(target.getStyles(), new TypeReference<>() {});

            long common = myStyles.stream()
                    .filter(targetStyles::contains)
                    .count();

            if (common > 0) {
                score += Math.min(common * 5, 15); // 1Í∞ú: 5Ï†ê, 2Í∞ú: 10Ï†ê, 3Í∞ú Ïù¥ÏÉÅ: 15Ï†ê
            }
        } catch (Exception e) {
            System.out.println("styles Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: " + e.getMessage());
        }

        return Math.min(score, 100);
    }
    private int calculateOverlappingDays(LocalDate aStart, LocalDate aEnd, LocalDate bStart, LocalDate bEnd) {
        LocalDate overlapStart = aStart.isAfter(bStart) ? aStart : bStart;
        LocalDate overlapEnd = aEnd.isBefore(bEnd) ? aEnd : bEnd;
        if (overlapStart.isAfter(overlapEnd)) return 0;
        return (int) ChronoUnit.DAYS.between(overlapStart, overlapEnd) + 1;
    }


    private boolean isSimilarRegion(String loc1, String loc2) {
        Map<String, String> regionMap = Map.ofEntries(
                Map.entry("ÏÑúÏö∏", "ÏàòÎèÑÍ∂å"), Map.entry("Í≤ΩÍ∏∞", "ÏàòÎèÑÍ∂å"), Map.entry("Ïù∏Ï≤ú", "ÏàòÎèÑÍ∂å"),
                Map.entry("Î∂ÄÏÇ∞", "ÏòÅÎÇ®"), Map.entry("ÎåÄÍµ¨", "ÏòÅÎÇ®"), Map.entry("Í≤ΩÎÇ®", "ÏòÅÎÇ®"),
                Map.entry("Í¥ëÏ£º", "Ìò∏ÎÇ®"), Map.entry("Ï†ÑÎ∂Å", "Ìò∏ÎÇ®"), Map.entry("Ï†ÑÎÇ®", "Ìò∏ÎÇ®")
                // ÌïÑÏöîÏãú Îçî Ï∂îÍ∞Ä
        );

        String r1 = regionMap.getOrDefault(loc1, loc1);
        String r2 = regionMap.getOrDefault(loc2, loc2);

        return r1.equals(r2);
    }




    @Override
    public Long sendRequest(Long senderId, MatchRequestDto request) {
        User sender = userRepository.findById(senderId).orElseThrow();
        User receiver = userRepository.findById(request.getReceiverId()).orElseThrow();
        TravelPlan plan = travelPlanRepository.findById(request.getPlanId()).orElseThrow();

        if (matchingRepository.existsBySenderIdAndReceiverIdAndPlanId(senderId, receiver.getId(), plan.getId())) {
            throw new IllegalStateException("Ïù¥ÎØ∏ ÏöîÏ≤≠Ìïú ÏÇ¨Ïö©ÏûêÏûÖÎãàÎã§.");
        }

        Matching matching = Matching.builder()
                .sender(sender)
                .receiver(receiver)
                .plan(plan)
                .status(MatchingStatus.PENDING)
                .createdAt(LocalDateTime.now())
                .build();

        matchingRepository.save(matching);

        // üîî ÏïåÎ¶º Ï†ÑÏÜ° (receiverÏóêÍ≤å)
        alarmService.sendAlarm(
                receiver.getId(),
                sender.getNickname(),
                Alarm.AlarmType.MATCH_REQUEST,
                sender.getNickname() + " ÎãòÏù¥ Îß§Ïπ≠ ÏöîÏ≤≠ÏùÑ Î≥¥ÎÉàÏäµÎãàÎã§."
        );

        return matching.getId();
    }

    @Override
    public void respondToRequest(Long matchId, MatchingStatus status) {
        Matching match = matchingRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Îß§Ïπ≠ ÏöîÏ≤≠ ÏóÜÏùå"));

        if (match.getStatus() != MatchingStatus.PENDING) {
            throw new IllegalStateException("Ïù¥ÎØ∏ ÏùëÎãµ Ï≤òÎ¶¨Îêú ÏöîÏ≤≠ÏûÖÎãàÎã§.");
        }

        match.updateStatus(status);

        if (status == MatchingStatus.ACCEPTED) {
            // ÏïåÎ¶º Ï†ÑÏÜ°
            alarmService.sendAlarm(
                    match.getSender().getId(),
                    match.getReceiver().getNickname(),
                    Alarm.AlarmType.MATCH_REQUEST,
                    match.getReceiver().getNickname() + " ÎãòÏù¥ Îß§Ïπ≠ÏùÑ ÏàòÎùΩÌñàÏäµÎãàÎã§. Ï±ÑÌåÖÏùÑ ÏãúÏûëÌï¥Î≥¥ÏÑ∏Ïöî!"
            );

            User sender = match.getSender();
            User receiver = match.getReceiver();

            TravelPlan senderPlan = travelPlanRepository.findFirstByUserIdOrderByStartDateDesc(sender.getId())
                    .orElse(null);
            TravelPlan receiverPlan = travelPlanRepository.findFirstByUserIdOrderByStartDateDesc(receiver.getId())
                    .orElse(null);

            if (senderPlan != null && receiverPlan != null) {

                // 1. senderPlan Î™®Ïßë Ï¢ÖÎ£å (Îß§Ïπ≠ ÏöîÏ≤≠ÌñàÏúºÎØÄÎ°ú Îçî Ïù¥ÏÉÅ Ïïà Î∞õÏùå)
                senderPlan.setRecruiting(false);

                // 2. receiverPlanÏùò ÌòÑÏû¨ Ïù∏Ïõê += senderPlanÏùò ÌòÑÏû¨ Ïù∏Ïõê
                int updatedReceiverPeople = receiverPlan.getCurrentPeople() + senderPlan.getCurrentPeople();
                receiverPlan.setCurrentPeople(updatedReceiverPeople);

                // 3. receiverPlanÎèÑ ÎßàÍ∞êÎêòÏóàÎäîÏßÄ ÌôïÏù∏
                if (updatedReceiverPeople >= receiverPlan.getNumberOfPeople()) {
                    receiverPlan.setRecruiting(false);
                }

                travelPlanRepository.save(senderPlan);
                travelPlanRepository.save(receiverPlan);
            }

            // üí¨ Ï±ÑÌåÖÎ∞© ÏÉùÏÑ± Îì± Ï∂îÍ∞Ä Î°úÏßÅ Í∞ÄÎä•
        }

    }


    @Override
    public void cancelRequest(Long matchId, Long senderId) {
        Matching match = matchingRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Îß§Ïπ≠ ÏóÜÏùå"));

        if (!match.getSender().getId().equals(senderId)) {
            throw new IllegalStateException("Î≥∏Ïù∏Ïù¥ Î≥¥ÎÇ∏ ÏöîÏ≤≠Îßå Ï∑®ÏÜåÌï† Ïàò ÏûàÏäµÎãàÎã§.");
        }

        if (match.getStatus() != MatchingStatus.PENDING) {
            throw new IllegalStateException("Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Îß§Ïπ≠ÏùÄ Ï∑®ÏÜåÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
        }

        matchingRepository.delete(match);
    }



    @Override
    public void rejectPlan(Long senderId, Long planId) {
        TravelPlan plan = travelPlanRepository.findById(planId).orElseThrow();
        User sender = userRepository.findById(senderId).orElseThrow();
        User receiver = plan.getUser();

        // Ïù¥ÎØ∏ Í±∞Ï†àÌïú Ïù¥Î†•Ïù¥ ÏûàÏúºÎ©¥ Ï§ëÎ≥µ Ï†ÄÏû• Ïïà ÌïòÍ≤å Ï≤òÎ¶¨
        boolean alreadyExists = matchingRepository
                .existsBySenderIdAndReceiverIdAndPlanId(senderId, receiver.getId(), planId);
        if (alreadyExists) return;

        Matching reject = Matching.builder()
                .sender(sender)
                .receiver(receiver)
                .plan(plan)
                .status(MatchingStatus.REJECTED)
                .createdAt(LocalDateTime.now())
                .build();

        matchingRepository.save(reject);
    }

    @Override
    public void cancelAcceptedMatch(Long matchId, Long userId) {
        Matching match = matchingRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Îß§Ïπ≠ ÏóÜÏùå"));

        if (match.getStatus() != MatchingStatus.ACCEPTED) {
            throw new IllegalStateException("ÏàòÎùΩÎêú Îß§Ïπ≠Îßå Ï∑®ÏÜåÌï† Ïàò ÏûàÏäµÎãàÎã§.");
        }

        if (!match.getSender().getId().equals(userId) && !match.getReceiver().getId().equals(userId)) {
            throw new IllegalStateException("Î≥∏Ïù∏Îßå Ï∑®ÏÜåÌï† Ïàò ÏûàÏäµÎãàÎã§.");
        }

        TravelPlan senderPlan = travelPlanRepository.findFirstByUserIdOrderByStartDateDesc(match.getSender().getId())
                .orElseThrow();
        TravelPlan receiverPlan = travelPlanRepository.findFirstByUserIdOrderByStartDateDesc(match.getReceiver().getId())
                .orElseThrow();

        receiverPlan.setCurrentPeople(receiverPlan.getCurrentPeople() - senderPlan.getCurrentPeople());
        senderPlan.setRecruiting(true);
        if (receiverPlan.getCurrentPeople() < receiverPlan.getNumberOfPeople()) {
            receiverPlan.setRecruiting(true);
        }

        // üîî ÏïåÎ¶º Ï∂îÍ∞Ä
        Long opponentId = match.getSender().getId().equals(userId)
                ? match.getReceiver().getId()
                : match.getSender().getId();
        User cancelUser = userRepository.findById(userId).orElseThrow();
        alarmService.sendAlarm(
                opponentId,
                cancelUser.getNickname(),
                Alarm.AlarmType.MATCH_REQUEST,
                cancelUser.getNickname() + " ÎãòÏù¥ Îß§Ïπ≠ ÏàòÎùΩÏùÑ Ï∑®ÏÜåÌñàÏäµÎãàÎã§."
        );

        matchingRepository.delete(match);
        travelPlanRepository.save(senderPlan);
        travelPlanRepository.save(receiverPlan);
    }

}
